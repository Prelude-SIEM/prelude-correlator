#!/usr/bin/python
# written by Jean-marc Vigne (jean-marc.vigne.ext@c-s.fr)

import sys, os, time, signal
import unittest
import threading
import subprocess  

# This file has been written to test the prelude-correlator debug mode. During the test, a bruteforce log will be generated by syslog-injector to the prelude-lml module and processed by prelude-correlator. Meanwhile, the context table updates should be displayed. 
# Test duration : ~ 20 seconds



# prelude-lml and prelude-manager should be launched during the test !
# custom data
SYSLOG_INJECTOR_PATH = "/usr/bin/syslog-injector.py"
LOCAL_IP_ADDRESS = "192.168.133.132"
BRUTEFORCE_LOG_PATH = "/usr/share/syslog-injector/data/bruteforce.txt"



# class : a prelude-correlator thread will launch a subprocess in the run method. This process will be stopped in the shutdown_pcorr_process method
class pcorrThread(threading.Thread):
	def __init__(self):
		threading.Thread.__init__(self)
		self.threadID = 2
		self.outputstring = ''
		self.stopsignal = False
	
	# method : a subprocess will launch prelude-correlator with debug mode and display the corresponding stdout file content. This method will terminate after the shutdown_pcorr_process call
 	def run(self):
	 	print "starting pcorrThread"
		self.proc1 = subprocess.Popen(['prelude-correlator','--debug=1'], stdout=subprocess.PIPE)
		while self.stopsignal ==False:
			outputchar = self.proc1.stdout.read(1)
			self.outputstring += outputchar
			sys.stdout.write(outputchar)
			sys.stdout.flush()
		print "\n exiting pcorrThread run method"		
		
	# method : a signal will be sent to the proc1 subprocess in order to shut it down. The last chars will be saved and displayed.
	def shutdown_pcorr_process(self):
		self.stopsignal = True
		self.proc1.send_signal(signal.SIGINT)
		
		remaining_output_string_after_shutdown = self.proc1.stdout.read()
 		self.outputstring += remaining_output_string_after_shutdown
 		sys.stdout.write(remaining_output_string_after_shutdown)
 		sys.stdout.flush()
		

# class : an injectorThread thread will launch a syslog-injector script
class injectorThread (threading.Thread):
	def __init__(self):
		threading.Thread.__init__(self)
		self.threadID = 3

	# method : the thread will sleep during 15 seconds. A subprocess will then launch the syslog-injector script
	def run(self):
		print "starting injectorThread"
		time.sleep(15)		
		TIME_STRING = 	"%s" %(time.ctime(time.time()))+"\n"
		self.proc2 = subprocess.Popen([SYSLOG_INJECTOR_PATH,'-v', '-l', '1', '-s', LOCAL_IP_ADDRESS, LOCAL_IP_ADDRESS, BRUTEFORCE_LOG_PATH], stdout=subprocess.PIPE)
		output_syslog_injector_thread = "\n"+"******************************************\n"*2+"SYSLOG MESSAGE INJECTION\n"+TIME_STRING
		output_syslog_injector_process = self.proc2.stdout.read()
		output_syslog_injector_thread += output_syslog_injector_process
		output_syslog_injector_thread += "******************************************\n"*2
		print output_syslog_injector_thread
		print "\n exiting injectorThread \n" 


#class : unittest class
class classetest(unittest.TestCase):
	# method : pcorrThread and injectorThread will be instanciated. After the start method call, the main thread will sleep during 20 seconds. It will then shutdown the proc1 subprocess and run the test assertion method.
	def test_bruteforce(self):
		
		threadpcorr = pcorrThread()
		threadinjector = injectorThread()
		
		threadpcorr.start()		
		threadinjector.start()
		time.sleep(20)
		threadpcorr.shutdown_pcorr_process()
		
		self.assertNotEqual(threadpcorr.outputstring.find("DEBUG"), -1, "DEBUG mode not detected.")
		print "\n"*5
		print "*****************************************\n"*4, "analyzed string" 
		print "*****************************************\n"*4
		print threadpcorr.outputstring
		
if __name__ == '__main__':
	unittest.main()
	
	




